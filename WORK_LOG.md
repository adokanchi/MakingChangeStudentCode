Name: Tony Dokanchi

| Date    |      Time       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Update |
|:--------|:---------------:|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
| April 5 |     9-10pm      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                      I tried to write abstract, efficient code. |
| Jan 26  |  11:40-11:59pm  |                                                                                                                                                                                                                           Coded a recursive brute-force algorithm (pretty much just tries every possible combination) just to get a feel for it. It passes the one test case that's small enough to run in a reasonable amount of time, which I guess is the best I could reasonably expect from this approach. |
| Jan 27  |  12:00-12:15am  |                                                            Trying to switch to an algorithm where I use dynamic programming to build up from smaller target values. i.e. I compute the number of ways to get to 1, 2, 3, etc. all the way to target. My current algorithm is correct for ordered sequences of coins, but the problem is designed around unordered sequences i.e. my algorithm considers 2+3 and 3+2 to be distinct ways of making change, which is incorrect. Not sure exactly how to fix this. |
| Jan 27  |  12:15-12:20am  | Immediately realized how to fix this doubling up issue. All I have to do is populate the counts[] array using only the first coin, then incorporate ways to use the second coin, then the third, etc. So instead of going in order from 0 to target and trying to compute the right value at each step, I could go coin by coin computing the possibilities. This ensures that I always pick the coins in the same order (i.e. whatever order they are in the coins array), removing the double-counting issue. |
| Jan 27  | 12:20am-12:30am |                                                                                                                                                                                                                             Was looking for optimizations, and found one small one: instead of starting the innermost for loop at i=1 then only running if i>=coinVal, we can just begin by setting i to coinVal and going from there, skipping unnecessary checks and all the steps from i==1 to i==coinVal-1. |
| Jan 28  |  11am-11:55am   |                                                                      Tried to work on a top-down algorithm instead of a bottom-up algorithm in class (the bottom-up one works well, it's just for the sake of it). My approach isn't working (I'm getting index out of bounds and I don't know why), and I'm not convinced it'll even work properly if I fix the errors. I'm worried about not being able to go faster than O(n*T^2) and worried about knowing how to avoid counting duplicates multiple times. |
| Jan 31  |    3:30-4pm     |                                                                                                                                                                                                          Coded the memoization approach that we discussed in class. It pretty much follows the exact logic we used in class, with the speedup for the one-coin case. This approach is about the same speed as the memoization approach, and it's O(T*n) space instead of O(T), so it's probably slightly worse. |


To add a new row to the table, click into a cell and then hit shift-enter.